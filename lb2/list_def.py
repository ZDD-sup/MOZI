def extended_euclidean(a, b):
    """
    Расширенный алгоритм Евклида: находит НОД двух чисел и коэффициенты x и y,
    такие что a * x + b * y = НОД(a, b).

    Параметры:
    a (int): Первое число.
    b (int): Второе число.

    Возвращает:
    tuple: Кортеж из трех элементов:
        - int: НОД(a, b)
        - int: Коэффициент x, такой что a * x + b * y = НОД(a, b)
        - int: Коэффициент y, такой что a * x + b * y = НОД(a, b

    Примечание:
    Алгоритм может использоваться для решения линейных диофантовых уравнений
    и для нахождения обратных элементов по модулю.
    """
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = extended_euclidean(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y


def modular_inverse(element, modulus):
    """
    Вычисляет обратный элемент в кольце вычетов по модулю.

    Параметры:
    element (int): Элемент, для которого требуется найти обратный по модулю.
    modulus (int): Модуль, относительно которого вычисляется обратный элемент.

    Возвращает:
    int или None: Обратный элемент для заданного элемента по модулю, если он существует. 
                  Если обратный элемент не существует (т.е. НОД(element, modulus) ≠ 1), 
                  возвращает None.

    Выводит:
    str: Сообщение о найденном обратном элементе или о его отсутствии.

    Примечание:
    Обратный элемент существует только для элементов, которые взаимно просты с модулем (т.е. их НОД равен 1).
    """
    gcd, x, _ = extended_euclidean(element, modulus)
    
    # Если НОД не равен 1, то обратного элемента не существует
    if gcd != 1:
        print(f"Элемент {element} не имеет обратного по модулю {modulus}")
        return None
    
    # Приводим x к положительному значению, если он отрицательный
    inverse = x % modulus
    print(f"Обратный элемент для {element} по модулю {modulus} равен {inverse}")
    return inverse


def solve_modular_equation(a, b, m):
    """
    Решает сравнение a * x ≡ b (mod m) и находит все решения, если они существуют.

    Параметры:
    a (int): Коэффициент перед переменной x в уравнении.
    b (int): Константа в уравнении.
    m (int): Модуль, по которому производится вычисление.

    Возвращает:
    list: Список всех решений x, удовлетворяющих уравнению. Если решений нет, возвращает пустой список.
    
    Выводит:
    str: Сообщение с найденными решениями или с информацией о том, что решений нет.
    
    Примечание:
    Уравнение имеет решение, если и только если НОД(a, m) делит b. 
    Если решение существует, оно будет представлено в виде всех эквивалентных классов по модулю m.
    """
    gcd, x, _ = extended_euclidean(a, m)
    
    # Проверяем, делится ли b на gcd
    if b % gcd != 0:
        print("Решений нет, так как НОД(a, m) не делит b.")
        return []

    # Находим частное решение x0, приводя x к положительному значению
    x0 = (x * (b // gcd)) % m
    solutions = [(x0 + i * (m // gcd)) % m for i in range(gcd)]
    
    # Выводим решения
    print(f"Решения для {a} * x ≡ {b} (mod {m}): {solutions}")
    return solutions


def encode(a: int, b: int, text: str, alphabet: str) -> str:
    """
    Шифрует текст с использованием линейного шифра (a * x + b) по заданному алфавиту.

    Параметры:
    a (int): Коэффициент для шифрования (множитель).
    b (int): Смещение для шифрования (константа).
    text (str): Входной текст, который необходимо зашифровать.
    alphabet (str): Строка, представляющая алфавит, используемый для шифрования.

    Возвращает:
    str: Зашифрованный текст, в котором символы, входящие в указанный алфавит, заменяются на соответствующие зашифрованные символы,
         а остальные символы (например, пробелы и пунктуация) остаются без изменений.
    """
    new_text = ""
    for letter in text:
        if letter == 'Ё':
            letter = 'Е'

        if letter in alphabet:
            x = alphabet.index(letter)
            y = (a * x + b) % len(alphabet)
            new_text += alphabet[y]
        else:
            new_text += letter

    return new_text